extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h> 
#include <iostream>
#include <pthread.h> 
#include <fstream>
#include <string>
#include <cstring>
#include <map>
#include "fileserver.h"

#define MAX_BUFFER_SIZE 1024

#define NUM_SOCKETS_ALLOWED 10

static int html_out(lua_State *L);

char *luaMessage;

using namespace std;

typedef struct {
	string version = "";
	string document = "";
	bool keepAlive = false;
}Http_intel;

//Writes to the socket
int writeSock(char *buff , FILE *write_fd){
	fprintf(write_fd, "%s", buff);
	fflush(write_fd);
}


//Checks to see if the http request is a GET request or not
bool isGetRequest(char *buff){
	bool found = false;

	if(strstr(buff,"GET")){
		found = true;
	}

	return found;
}

//Checks to see if the connection should be kept alive
bool shouldKeepAlive(char *buff){
	bool keepAlive = false;	

	if(strcasestr(buff, "HTTP/1.1") || strcasestr(buff,"Connection: Keep-Alive")){
		keepAlive = true;
	}

	return keepAlive;
}

//Gets the HTTP version
string getVersion(string request){
	string version = "";

	if(request.find("HTTP/1.1") != -1){
		version = "HTTP/1.1 ";
	}else{
		version = "HTTP/1.0 ";
	}
	return version;
}

int getFirstPosition(string request, string item){
	int first_pos = 0;
	first_pos = request.find(item);
	return first_pos;
}

int getLastPosition(string request, string item){
	int last_pos = 0;
	last_pos = request.find(item);
	return last_pos;
}

//Parses the information from the form and stores it as a key value pair
map<string,string> parseForm(string request){
	map<string,string> parsedItems;
	int first_pos, last_pos;

	first_pos = getFirstPosition(request, "firstname=");
	last_pos = getLastPosition(request, "&lastname");
	parsedItems["firstname"] = request.substr(first_pos+10,last_pos-first_pos-10);
	
	first_pos = getFirstPosition(request, "lastname=");
	last_pos = getLastPosition(request, " HTTP");
	parsedItems["lastname"] = request.substr(first_pos+9,last_pos-first_pos-9);

	return parsedItems;
}

//Gets and stores the requested document name
string getDocumentName(string request){
	int first_pos = request.find("GET");
	int last_pos;
	
	if(request.find("HTTP/1.1") != -1){
		last_pos = request.find(" HTTP/1.1");
	}else{
		last_pos = request.find(" HTTP/1.0");
	}

	string contentRequest = request.substr(first_pos + 5,last_pos-first_pos - 5);

	return contentRequest;
}

//Gets size of a specified file.
int getFileSize(string fileName){
	int size = 0;
	ifstream theFile (fileName,ios::binary | ios::ate);
	
	theFile.seekg(0, ios::end);
	size = theFile.tellg();
	theFile.close();
	return size;
}

//Reads and returns contents of a file
string readFile(string fileName){
	int fileSize = getFileSize(fileName);
	ifstream getContent(fileName, ios::in);
	string theContents = "";
	string temp = "";

	while(getline(getContent,temp)){
		if(!getContent.eof()){
			theContents += temp + '\n';
		}
		else{
			theContents += temp;
		}
	}

	getContent.close();
	return theContents;
}

//Sets up the stack and runs the lua script
void runLua(map<string,string> items){
	int ret, result;
	string firstname = items["firstname"], lastname = items["lastname"];
	lua_State *L = luaL_newstate();

    	luaL_openlibs(L);

	ret = luaL_loadfile(L, "signup.lua");
	
	if (ret) {
		cerr << "Couldn't load file: " << lua_tostring(L, -1) << endl;
		exit(1);
   	}
	
	lua_newtable(L);

	lua_pushstring(L, "firstname");
    	lua_pushstring(L, firstname.c_str());

	lua_rawset(L, -3);

	lua_pushstring(L, "lastname");
    	lua_pushstring(L, lastname.c_str());

	lua_rawset(L, -3);
	lua_setglobal(L, "Info");

	int *ud = (int *) lua_newuserdata(L, sizeof(int));
    	*ud = 1;

	lua_pushcclosure(L, html_out, 1);
	
	lua_setglobal(L, "html_out");
	result = lua_pcall(L, 0, 1, 0);
	if (result) {
	    cerr << "Failed to run script: " << lua_tostring(L, -1) << endl;
	    exit(1);
	}
	lua_pop(L, 1);
    	lua_close(L);
}

//Function called by the lua script
//Also stores the messaged generated by the lua script
static int html_out(lua_State *L) {
	  int *fd = (int *) lua_touserdata(L, lua_upvalueindex(1));
	  char *msg = (char *) lua_tostring(L, -1);
	  write(*fd, msg, strlen(msg));
	  luaMessage = msg;

	  return 0;	
}

//Generates the html for the lua message
string generateHTML(char *mess){
	string htmlMessage = "";
	string message(mess);
	htmlMessage = "<!DOCTYPE html>\r\n<html>\r\n<body>\r\n<h1 style='background-color:green;'>"+message+"</h1>\r\n</body>\r\n</html>";
	
	return htmlMessage;
}

//Generates and sends the 200 HTTP response as well as the requested document
void goodRequest(string version, string dt, string fileName, bool generatehtml, FILE *write_fd){
	char response[MAX_BUFFER_SIZE];
	string content_type = "Content-Type: text/html\r\n";
	string content_length = "";
	string date = "";
	string rep = "";

	if(generatehtml){
		string html = generateHTML(luaMessage);
		version += "200 OK\r\n";
		date = "Date: " + dt;
		content_length = "Content-Length: " + to_string(html.length()) + "\r\n\r\n"; 
		rep = version + date + content_type + content_length + html;
		strcpy(response, rep.c_str());	
	}else{
		version += "200 OK\r\n";
		date = "Date: " + dt;
		content_length = "Content-Length: " + to_string(getFileSize(fileName)) + "\r\n\r\n"; 		
		rep = version + date + content_type + content_length + readFile(fileName);
		strcpy(response, rep.c_str());	
	}

	writeSock(response, write_fd);
}

//Generates and sends the 404 Not Found HTTP response
void badRequest(string version, string dt, FILE* write_fd){
	char response[MAX_BUFFER_SIZE];	
	string content_type = "Content-Type: text/html\r\n";
	string content_length = "";
	string date = "";
	string rep = "";

	version += "404 Not Found\r\n";
	content_length = "Content-Length: " + to_string(getFileSize("notFound.txt")) + "\r\n\r\n"; 	
	rep = version + "Date: " + date + content_type + content_length + readFile("notFound.txt");
	strcpy(response, rep.c_str());

	writeSock(response, write_fd);
}

//Services the request based on the type of document requested
void serviceRequest(char *buff, FILE *write_fd, Http_intel htpi){
	
	string getRequest(buff);
	string version = "";
	time_t now = time(0);
	string dt = ctime(&now);
	map<string,string> items;
	char response[MAX_BUFFER_SIZE];
	int first_pos, last_pos;	

	
	if(htpi.document.find("singup.lua?") != -1){
		try{
			first_pos = getFirstPosition(htpi.document,"?firstname");
			map<string,string> items;
			first_pos = htpi.document.find("?firstname");
			items = parseForm(htpi.document.substr(first_pos+1, last_pos-first_pos-1));		
			runLua(items);
			goodRequest(htpi.version, dt, "", true, write_fd);
		}catch(exception& e){}
	}else if(htpi.document == ""){
		goodRequest(htpi.version, dt, "index.html", false, write_fd);
	}else{
		if(!ifstream(htpi.document)){
			cerr << "doc: " << htpi.document << "t" << endl;
			badRequest(htpi.version, dt, write_fd);
		}else{
			cerr << "doc2: " << htpi.document << "t" << endl;
			goodRequest(htpi.version, dt, htpi.document, false, write_fd);
		}
	}
}

//Reads and stores information from the socket.
//Also handles whether the connection should stay a live or not
int readSock(int clisock){
	char buff[MAX_BUFFER_SIZE];
	int read_sock = clisock;
	FILE *read_fd = fdopen(read_sock, "r");
	FILE *write_fd = fdopen(read_sock, "w");
	int done = 0;
	int result = 1;
	bool getRequest = false;
	Http_intel htpi;
	

	while(!done) {
		if(fgets(buff, MAX_BUFFER_SIZE, read_fd) == NULL && htpi.keepAlive == false){
			done = 1;
			result = 0;
			break;
		}

		if(getRequest == false && strlen(buff) != 2){
			getRequest = isGetRequest(buff);
			if(getRequest == true){
				htpi.version = getVersion(string(buff));
				htpi.document = getDocumentName(string(buff));
				serviceRequest(buff, write_fd, htpi);
				cerr << "I got " << htpi.version << endl;
			}
		}

		if(htpi.keepAlive == false && getRequest == true){
			htpi.keepAlive = shouldKeepAlive(buff);
		}

		if(strlen(buff) == 2){
			getRequest = false;	
		}

		if ((getRequest == false && htpi.keepAlive == false) || (strlen(buff) == 2 && htpi.keepAlive == false)) {
		 	done = 1;
			result = 0;
		}	
	}
	
	fclose(read_fd);
	fclose(write_fd);


	return result;

}

//Handles connection between client and server.
void* connectHandler(void* args){
	int clisock = (intptr_t) args;
	while(readSock(clisock));
	close(clisock);
	pthread_exit(NULL);
}

	


//Handles the creation of the threads
void handleConnection(int clisock){
		pthread_attr_t attribs;
		pthread_t thread;
		pthread_attr_init(&attribs);
		pthread_attr_setdetachstate(&attribs, PTHREAD_CREATE_DETACHED);
		pthread_create(&thread, &attribs, connectHandler, (void*)(intptr_t)clisock);
}


//Sets up and starts the server. Returns 0 if sucessful and 1 if not.

int run_server(int port){
	struct sockaddr_in server_addr, cli_addr;
	unsigned int clilen;
	int result = 0;
	int client_num = 0;
	int newsock_con,serv_socket_num;

	if((serv_socket_num = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		result = 1;
		return result;
	}

	memset((void *) &server_addr, 0, sizeof(server_addr));
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	server_addr.sin_port = htons(port);

	if(bind(serv_socket_num, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
		cerr << "Bind error.";
		result = 1;
		return result;
	}

	listen(serv_socket_num, NUM_SOCKETS_ALLOWED);

	while(1){
		clilen = sizeof(cli_addr);
		newsock_con = accept(serv_socket_num, (struct sockaddr *) &cli_addr, &clilen);

		if(newsock_con < 0) {
			cerr << "Accept error." << endl;
			result = 1;
			return result;
		}

		cerr << "Listening to client " << client_num << " on port number " << to_string(port) << endl;
      		client_num++;

		handleConnection(newsock_con);

	}

	return result;
}
